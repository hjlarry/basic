/*
编写一个函数setbits(x,p,n,y)，该函数返回对x进行如下操作的结果值
将x中从右边第p位开始的n个位设置为y中最右边n位的值，x的其余各位保持不变
*/

unsigned setbits(unsigned x, int p, int n, unsigned y)
{
    return (x & ~(~(~0 << n) << (p + 1 - n))) | ((y & ~(~0 << n)) << (p + 1 - n));
}

/*
假设：
x:xxxxxxnnnxxx
y:yyyyyyyyynnn

需要把x的这些n位清零，y中除最右边n位以外的值清零并左移到第p位处，然后两步的结果进行OR
x: xxxxxx000xxx
y: 000000nnn000

x的n位清零操作：
先把一个所有位为1的屏蔽码左移n位，在它的最右边制造出n位0，然后取反:
~(~0 << n)  假设n=3，那么现在得到的是111
接下来把屏蔽码最右边的n个1左移到p位处:
~(~0 << n) << (p + 1 - n)  假设p=5，那么现在得到的是 111000
再取反和x进行AND操作:
x & ~(~(~0 << n) << (p + 1 - n)) 得到 xxxxxx000xxx

y的操作：
先用最右端的n位全为1的屏蔽码对y进行AND操作，就得到了y最右端的n位:
y & ~(~0 << n) 
然后把它移至p位即可:
(y & ~(~0 << n)) << (p + 1 - n)

*/